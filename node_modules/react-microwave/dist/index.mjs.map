{"version":3,"sources":["../src/microwave/assert.ts","../src/microwave/diff.ts","../src/microwave/utils.ts","../src/microwave/timer.ts","../src/microwave/report.ts","../src/microwave/suite.ts","../src/microwave/index.ts"],"sourcesContent":["// Almost an identical re-write of UVU.assert\n\nimport { dequal } from \"dequal\"\nimport { compare, lines } from \"./diff\"\nimport { dedent } from \"./utils\"\n\ntype Opts = {\n  message?: string\n  details: false | string\n  generated: boolean\n  operator: string\n  expects: any\n  actual: any\n}\n\nexport class Assertion extends Error {\n  name: \"Assertion\"\n  code: \"ERR_ASSERTION\"\n  details: false | string\n  generated: boolean\n  operator: string\n  expects: any\n  actual: any\n\n  constructor(opts: Opts) {\n    super(opts.message ?? \"\")\n    this.name = \"Assertion\"\n    this.code = \"ERR_ASSERTION\"\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n    this.details = opts?.details || false\n    this.generated = !!opts?.generated\n    this.operator = opts?.operator\n    this.expects = opts?.expects\n    this.actual = opts?.actual\n  }\n}\n\ntype Types = \"string\" | \"number\" | \"boolean\" | \"object\" | \"undefined\" | \"function\"\n\nexport type Message = string | Error\n\nexport type Detailer<Actual = any, Expects = any> = (actual: Actual, expects: Expects) => string\n\nfunction assert<Actual = any, Expects = any>(\n  bool: boolean,\n  actual: Actual,\n  expects: Expects,\n  operator: string,\n  detailer?: false | Detailer<Actual, Expects>,\n  backup?: string,\n  msg?: Message\n) {\n  if (bool) return\n  let message = msg || backup\n  if (msg instanceof Error) throw msg\n  let details = detailer && detailer(actual, expects)\n  throw new Assertion({\n    actual,\n    expects,\n    operator,\n    message: message as string | undefined,\n    details: details ?? false,\n    generated: !msg,\n  })\n}\n\nexport function ok<T = any>(actual: T, msg?: Message): asserts actual\nexport function ok<T = any>(val: T, msg?: Message) {\n  assert(!!val, false, true, \"ok\", false, \"Expected value to be truthy\", msg)\n}\n\nexport function is(actual: any, expects: any, msg?: Message): void\nexport function is(val: any, exp: any, msg?: Message) {\n  assert(val === exp, val, exp, \"is\", compare, \"Expected values to be strictly equal:\", msg)\n}\n\nexport function equal(actual: any, expects: any, msg?: Message): void\nexport function equal(val: any, exp: any, msg?: Message) {\n  assert(dequal(val, exp), val, exp, \"equal\", compare, \"Expected values to be deeply equal:\", msg)\n}\n\nexport function unreachable(msg?: Message): void\nexport function unreachable(msg?: Message) {\n  assert(false, true, false, \"unreachable\", false, \"Expected not to be reached!\", msg)\n}\n\nexport function type(actual: any, expects: Types, msg?: Message): void\nexport function type(val: any, exp: Types, msg?: Message) {\n  let tmp = typeof val\n  assert(tmp === exp, tmp, exp, \"type\", false, `Expected \"${tmp}\" to be \"${exp}\"`, msg)\n}\n\nexport function instance(actual: any, expects: any, msg?: Message): void\nexport function instance(val: any, exp: any, msg?: Message) {\n  let name = \"`\" + (exp.name || exp.constructor.name) + \"`\"\n  assert(val instanceof exp, val, exp, \"instance\", false, `Expected value to be an instance of ${name}`, msg)\n}\n\nexport function match(actual: string, expects: string | RegExp, msg?: Message): void\nexport function match(val: any, exp: string | RegExp, msg?: Message) {\n  if (typeof exp === \"string\") {\n    assert(val.includes(exp), val, exp, \"match\", false, `Expected value to include \"${exp}\" substring`, msg)\n  } else {\n    assert(exp.test(val), val, exp, \"match\", false, `Expected value to match \\`${String(exp)}\\` pattern`, msg)\n  }\n}\n\nexport function snapshot(actual: string, expects: string, msg?: Message): void\nexport function snapshot(val: string, exp: string, msg?: Message) {\n  val = dedent(val)\n  exp = dedent(exp)\n  assert(val === exp, val, exp, \"snapshot\", lines, \"Expected value to match snapshot:\", msg)\n}\n\nconst lineNums = (x: string, y: string) => lines(x, y, 1)\n\nexport function fixture(actual: string, expects: string, msg?: Message): void\nexport function fixture(val: string, exp: string, msg?: Message) {\n  val = dedent(val)\n  exp = dedent(exp)\n  assert(val === exp, val, exp, \"fixture\", lineNums, \"Expected value to match fixture:\", msg)\n}\n\nexport function throws(fn: Function, expects?: Message | RegExp | Function, msg?: Message): void\nexport function throws(blk: Function, exp?: Message | RegExp | Function | null, msg?: Message) {\n  if (!msg && typeof exp === \"string\") {\n    msg = exp\n    exp = null\n  }\n\n  try {\n    blk()\n    assert(false, false, true, \"throws\", false, \"Expected function to throw\", msg)\n  } catch (err) {\n    if (err instanceof Assertion) throw err\n\n    if (typeof exp === \"function\") {\n      assert(exp(err), false, true, \"throws\", false, \"Expected function to throw matching exception\", msg)\n    } else if (exp instanceof RegExp) {\n      assert(\n        exp.test((err as Error).message),\n        false,\n        true,\n        \"throws\",\n        false,\n        `Expected function to throw exception matching \\`${String(exp)}\\` pattern`,\n        msg\n      )\n    }\n  }\n}\n\n// ---\nexport function not(actual: any, msg?: Message): void\nexport function not(val: any, msg?: Message) {\n  assert(!val, true, false, \"not\", false, \"Expected value to be falsey\", msg)\n}\n\nnot.ok = not\n\nis.not = function (val: any, exp: any, msg?: Message) {\n  assert(val !== exp, val, exp, \"is.not\", false, \"Expected values not to be strictly equal\", msg)\n}\n\nnot.equal = function (val: any, exp: any, msg?: Message) {\n  assert(!dequal(val, exp), val, exp, \"not.equal\", false, \"Expected values not to be deeply equal\", msg)\n}\n\nnot.type = function (val: any, exp: Types, msg?: Message) {\n  let tmp = typeof val\n  assert(tmp !== exp, tmp, exp, \"not.type\", false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg)\n}\n\nnot.instance = function (val: any, exp: any, msg?: Message) {\n  let name = \"`\" + (exp.name || exp.constructor.name) + \"`\"\n  assert(!(val instanceof exp), val, exp, \"not.instance\", false, `Expected value not to be an instance of ${name}`, msg)\n}\n\nnot.snapshot = function (val: string, exp: string, msg?: Message) {\n  val = dedent(val)\n  exp = dedent(exp)\n  assert(val !== exp, val, exp, \"not.snapshot\", false, \"Expected value not to match snapshot\", msg)\n}\n\nnot.fixture = function (val: string, exp: string, msg?: Message) {\n  val = dedent(val)\n  exp = dedent(exp)\n  assert(val !== exp, val, exp, \"not.fixture\", false, \"Expected value not to match fixture\", msg)\n}\n\nnot.match = function match(val: any, exp: string | RegExp, msg?: Message) {\n  if (typeof exp === \"string\") {\n    assert(!val.includes(exp), val, exp, \"not.match\", false, `Expected value not to include \"${exp}\" substring`, msg)\n  } else {\n    assert(!exp.test(val), val, exp, \"not.match\", false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg)\n  }\n}\n\nnot.throws = function (blk: Function, exp?: Message | RegExp | Function | null, msg?: Message) {\n  if (!msg && typeof exp === \"string\") {\n    msg = exp\n    exp = null\n  }\n\n  try {\n    blk()\n  } catch (err) {\n    if (typeof exp === \"function\") {\n      assert(!exp(err), true, false, \"not.throws\", false, \"Expected function not to throw matching exception\", msg)\n    } else if (exp instanceof RegExp) {\n      assert(\n        !exp.test((err as Error).message),\n        true,\n        false,\n        \"not.throws\",\n        false,\n        `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`,\n        msg\n      )\n    } else if (!exp) {\n      assert(false, true, false, \"not.throws\", false, \"Expected function not to throw\", msg)\n    }\n  }\n}\n","// An almost direct re-export of UVU.diff, but geared towards the browser and html-formatted output\n\nimport * as diff from \"diff\"\n\nconst colors = {\n  \"--\": \"--\",\n  \"··\": \"··\",\n  \"++\": \"++\",\n}\n\ntype ColorSymbol = keyof typeof colors\n\ntype DiffObject = { removed?: boolean; added?: boolean; value: string }\n\ntype SortK = string | number | any\n\nconst HTMLColoredFormatter: Record<string, (str: string) => string> = {\n  \"--\": (str: string) =>\n    `<span class=\"html-colored-formatter diff-removed red\" style=\"color: var(--color-scale-red-5)\">${str}</span>`,\n  \"··\": (str: string) =>\n    `<span class=\"html-colored-formatter diff-stayed grey\" style=\"color: var(--color-scale-gray-4)\">${str}</span>`,\n  \"++\": (str: string) =>\n    `<span class=\"html-colored-formatter diff-added green\" style=\"color: var(--color-scale-green-4)\">${str}</span>`,\n  TITLE: (str: string) => `<span class=\"html-colored-formatter title italic\">${str}</span>`,\n  TAB: (str: string) => `<span class=\"html-colored-formatter tab dim\">${str}</span>`,\n  DIM: (str: string) => `<span class=\"html-colored-formatter dim\">${str}</span>`,\n  dim: (str: string) => `<span class=\"html-colored-formatter dim\">${str}</span>`,\n  SPACE: (str: string) => `<span class=\"html-colored-formatter space dim\">${str}</span>`,\n  NL: (str: string) => `<span class=\"html-colored-formatter new-line dim\">${str}</span>`,\n  UNDERLINE: (str: string) => `<span class=\"html-colored-formatter underline\">${str}</span>`,\n  underline: (str: string) => `<span class=\"html-colored-formatter underline\">${str}</span>`,\n}\n\nconst HTMLLOG = (sym: ColorSymbol, str: string) => sym + HTMLPRETTY(str) + \"\\n\\n\"\nconst HTMLLINE = (num: number, x: number) => \"L\" + String(num).padStart(x, \"0\") + \" \"\nconst HTMLPRETTY = (str: string) => {\n  const prettifiedString = str\n    .replace(/[ ]/g, \"&nbsp;\")\n    .replace(/\\t/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\")\n    .replace(/(\\r?\\n)/g, \"<br /><br />\")\n\n  return `<span class=\"pretty\">${prettifiedString}</span>`\n}\n\nexport function line(obj: DiffObject, prev: number, pad?: number) {\n  let char: ColorSymbol = obj.removed ? \"--\" : obj.added ? \"++\" : \"··\"\n  let arr = obj.value.replace(/\\r?\\n$/, \"\").split(\"\\n\")\n  let i = 0\n  let tmp\n  let out = \"\"\n\n  if (obj.added) out += \"Expected:\" + \"\\n\"\n  else if (obj.removed) out += \"Actual:\" + \"\\n\"\n\n  for (; i < arr.length; i++) {\n    tmp = arr[i]\n    if (tmp != null) {\n      if (prev) out += HTMLLINE(prev + i, pad as number)\n      out += HTMLLOG(char, tmp || \"\\n\")\n    }\n  }\n\n  return out\n}\n\nexport function lines(input: string, expect: string, linenum = 0) {\n  let i = 0\n  let tmp\n  let output = \"\"\n  let arr = diff.diffLines(input, expect)\n  let pad = String(expect.split(/\\r?\\n/g).length - linenum).length\n\n  for (; i < arr.length; i++) {\n    output += line((tmp = arr[i]), linenum, pad)\n    if (linenum && !tmp.removed) linenum += tmp?.count ?? 0\n  }\n\n  return output\n}\n\nexport function circular() {\n  const cache = new Set()\n\n  return function print(key: string, val: any) {\n    if (val === void 0) return \"[__VOID__]\"\n    if (typeof val === \"number\" && val !== val) return \"[__NAN__]\"\n    if (!val || typeof val !== \"object\") return val\n    if (cache.has(val)) return \"[Circular]\"\n    cache.add(val)\n    return val\n  }\n}\n\nexport function stringify(input: any) {\n  return JSON.stringify(input, circular(), 2)\n    .replace(/\"\\[__NAN__\\]\"/g, \"NaN\")\n    .replace(/\"\\[__VOID__\\]\"/g, \"undefined\")\n}\n\nexport function arrays(input: Array<any>, expect: Array<any>) {\n  let arr = diff.diffArrays(input, expect)\n  let i = 0\n  let j = 0\n  let k = 0\n  let tmp\n  let val\n  let char: keyof typeof HTMLColoredFormatter\n  let isObj\n  let str\n  let out = HTMLLOG(\"··\", \"[\")\n\n  for (; i < arr.length; i++) {\n    char = (tmp = arr[i]).removed ? \"--\" : tmp.added ? \"++\" : \"··\"\n\n    if (tmp.added) {\n      out += HTMLColoredFormatter[char](HTMLColoredFormatter.underline(HTMLColoredFormatter.TITLE(\"Expected:\")) + \"\\n\")\n    } else if (tmp.removed) {\n      out += HTMLColoredFormatter[char](HTMLColoredFormatter.underline(HTMLColoredFormatter.TITLE(\"Actual:\")) + \"\\n\")\n    }\n\n    for (j = 0; j < tmp.value.length; j++) {\n      isObj = tmp.value[j] && typeof tmp.value[j] === \"object\"\n      val = stringify(tmp.value[j]).split(/\\r?\\n/g)\n      for (k = 0; k < val.length; ) {\n        str = \"  \" + val[k++] + (isObj ? \"\" : \",\")\n        if (isObj && k === val.length && j + 1 < tmp.value.length) str += \",\"\n        out += HTMLLOG(char as ColorSymbol, str)\n      }\n    }\n  }\n\n  return out + HTMLLOG(\"··\", \"]\")\n}\n\nexport function direct(input: any, expect: any, lenA = String(input).length, lenB = String(expect).length) {\n  let gutter = 4\n  let lenC = Math.max(lenA, lenB)\n  let typeA = typeof input\n  let typeB = typeof expect\n\n  if (typeA !== typeB) {\n    gutter = 2\n\n    let delA = gutter + lenC - lenA\n    let delB = gutter + lenC - lenB\n\n    input += \" \".repeat(delA) + HTMLColoredFormatter.dim(`[${typeA}]`)\n    expect += \" \".repeat(delB) + HTMLColoredFormatter.dim(`[${typeB}]`)\n\n    lenA += delA + typeA.length + 2\n    lenB += delB + typeB.length + 2\n    lenC = Math.max(lenA, lenB)\n  }\n\n  let output =\n    HTMLColoredFormatter[\"++\"](\n      \"++\" + expect + \" \".repeat(gutter + lenC - lenB) + HTMLColoredFormatter.TITLE(\"(Expected)\")\n    ) + \"\\n\"\n  return (\n    output +\n    HTMLColoredFormatter[\"--\"](\n      \"--\" + input + \" \".repeat(gutter + lenC - lenA) + HTMLColoredFormatter.TITLE(\"(Actual)\")\n    ) +\n    \"\\n\"\n  )\n}\n\nexport function chars(input: string, expect: string) {\n  let arr = diff.diffChars(input, expect)\n  let i = 0\n  let output = \"\"\n  let tmp\n\n  let l1 = input.length\n  let l2 = expect.length\n\n  let p1 = HTMLPRETTY(input)\n  let p2 = HTMLPRETTY(expect)\n\n  tmp = arr[i]\n\n  if (l1 === l2) {\n    // no length offsets\n  } else if (tmp.removed && arr[i + 1]) {\n    let del = (tmp?.count ?? 0) - (arr[i + 1].count ?? 0)\n    if (del == 0) {\n      // wash~\n    } else if (del > 0) {\n      expect = \" \".repeat(del) + expect\n      p2 = \" \".repeat(del) + p2\n      l2 += del\n    } else if (del < 0) {\n      input = \" \".repeat(-del) + input\n      p1 = \" \".repeat(-del) + p1\n      l1 += -del\n    }\n  }\n\n  output += direct(p1, p2, l1, l2)\n\n  if (l1 === l2) {\n    for (tmp = \"  \"; i < l1; i++) {\n      tmp += input[i] === expect[i] ? \" \" : \"^\"\n    }\n  } else {\n    for (tmp = \"  \"; i < arr.length; i++) {\n      tmp += (arr[i].added || arr[i].removed ? \"^\" : \" \").repeat(Math.max(arr[i]?.count ?? 0, 0))\n      if (i + 1 < arr.length && ((arr[i].added && arr[i + 1].removed) || (arr[i].removed && arr[i + 1].added))) {\n        ;(arr[i + 1].count as number) -= arr[i]?.count ?? 0\n      }\n    }\n  }\n\n  return output + tmp\n}\n\nexport function sort(input: any, expect: any) {\n  var k: SortK\n  var i = 0\n  var tmp: any\n  var isArr = Array.isArray(input)\n  var keys: Array<SortK> = []\n  var out: any[] | Record<string | number, any> = isArr ? Array(input.length) : {}\n\n  if (isArr) {\n    for (i = 0; i < (out?.length ?? 0); i++) {\n      tmp = input[i]\n      if (!tmp || typeof tmp !== \"object\") {\n        out[i] = tmp\n      } else {\n        out[i] = sort(tmp, expect[i]) // might not be right\n      }\n    }\n  } else {\n    for (k in expect) keys.push(k)\n\n    for (; i < keys.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(input, (k = keys[i]))) {\n        if (!(tmp = input[k]) || typeof tmp !== \"object\") out[k as keyof typeof out] = tmp\n        else out[k as keyof typeof out] = sort(tmp, expect[k])\n      }\n    }\n\n    for (k in input) {\n      if (!out.hasOwnProperty(k)) {\n        out[k as keyof typeof out] = input[k] // expect didnt have\n      }\n    }\n  }\n\n  return out\n}\n\nexport function compare(input: any, expect: any) {\n  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect)\n  if (expect instanceof RegExp) return chars(\"\" + input, \"\" + expect)\n\n  let isA = input && typeof input == \"object\"\n  let isB = expect && typeof expect == \"object\"\n\n  if (isA && isB) input = sort(input, expect)\n  if (isB) expect = stringify(expect)\n  if (isA) input = stringify(input)\n\n  if (expect && typeof expect == \"object\") {\n    input = stringify(sort(input, expect))\n    expect = stringify(expect)\n  }\n\n  isA = typeof input == \"string\"\n  isB = typeof expect == \"string\"\n\n  if (isA && /\\r?\\n/.test(input)) return lines(input, \"\" + expect)\n  if (isB && /\\r?\\n/.test(expect)) return lines(\"\" + input, expect)\n  if (isA && isB) return chars(input, expect)\n\n  return direct(input, expect)\n}\n","import { compare } from \"./diff\"\n\nexport const GUTTER = \"\\n        \"\nexport const IGNORE = /^\\s*at.*(?:\\(|\\s)(?:node|(internal\\/[\\w/]*))/\n\nexport function stack(stack: string, idx: number) {\n  let i = 0\n  let line\n  let out = \"\"\n  let arr = stack.substring(idx).replace(/\\\\/g, \"/\").split(\"\\n\")\n  for (; i < arr.length; i++) {\n    line = arr[i].trim()\n    if (line.length && !IGNORE.test(line)) {\n      out += \"\\n    \" + line\n    }\n  }\n\n  return out + \"\\n\"\n}\n\nexport const format = (name: string, err: any, suite = \"\") => {\n  let { details, operator = \"\" } = err\n  let idx = err.stack && err.stack.indexOf(\"\\n\")\n  if (err.name.startsWith(\"AssertionError\") && !operator.includes(\"not\")) details = compare(err.actual, err.expected) // TODO?\n\n  let htmlStr = `<span>`\n  htmlStr += `<span class=\"error-text suite-name\">${\" \" + \"✘ \" + ` ${suite} >>> 🚀 `}</span>`\n  htmlStr += `<span class=\"error-text test-name\">${name}</span>`\n  htmlStr += `</span>`\n\n  htmlStr += \"\\n    \" + err.message + (operator ? `  (${operator})` : \"\") + \"\\n\"\n  if (details) htmlStr += GUTTER + details.split(\"\\n\").join(GUTTER)\n  if (!!~idx) htmlStr += stack(err.stack, idx)\n  return htmlStr + \"\\n\"\n}\n\nexport function dedent(str: string) {\n  str = str.replace(/\\r?\\n/g, \"\\n\")\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm)\n  let i = 0\n  let min = 1 / 0\n  let len = (arr || []).length\n  for (; i < len; i++) min = Math.min(min, arr?.[i]?.length ?? Number.POSITIVE_INFINITY)\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, \"gm\"), \"\") : str\n}\n","import type { IMicrowaveTimer } from \"./types\"\n\nexport class MicrowaveTimer implements IMicrowaveTimer {\n  public startTs: number\n  public finishTs?: number\n  public duration?: number\n  public stopTimer: () => string | number\n\n  public constructor(now?: number, formatted: boolean = false) {\n    const { start, timer } = this.createTimer(now ?? this.getNow(), formatted)\n    this.startTs = start\n    this.stopTimer = timer\n  }\n\n  private getNow() {\n    return typeof performance < \"u\" ? performance.now() : Date.now()\n  }\n\n  private createTimer(now = this.getNow(), formatted: boolean = false) {\n    return {\n      start: now,\n      timer: () => {\n        this.finishTs = this.getNow()\n        this.duration = this.finishTs - now\n        return formatted ? this.duration.toFixed(2) + \"ms\" : this.duration\n      },\n    }\n  }\n}\n","import type {\n  ReportStats,\n  TestSuiteSummaryResults,\n  ITestSuiteSummary,\n  TestCaseSummaryResults,\n  ITestCaseSummary,\n  MicrowaveReportJson,\n  SuiteName,\n} from \"./types\"\nimport { MicrowaveTimer } from \"./timer\"\n\nexport const createEmptyStats = (): ReportStats => ({\n  total: 0,\n  passed: 0,\n  failed: 0,\n  skipped: 0,\n  ok: true,\n  duration: 0,\n  startTs: 0,\n  finishTs: 0,\n})\n\nconst createEmptyTestCaseResults = (\n  order?: number,\n  description?: string,\n  suiteName?: string,\n  startTs?: number\n): TestCaseSummaryResults => ({\n  order: order ?? -1,\n  description: description ?? \"\",\n  suiteName: suiteName ?? \"\",\n  annotations: [],\n  ok: true,\n  retry: 0,\n  errors: [],\n  status: \"passed\",\n  startTs: startTs ?? 0,\n  finishTs: 0,\n  duration: 0,\n})\n\nconst createEmptyTestSuiteResults = (\n  suiteName: SuiteName,\n  suiteOrder: number,\n  total: number,\n  startTs?: number\n): TestSuiteSummaryResults => ({\n  suiteName,\n  suiteOrder,\n  tests: [],\n  stats: {\n    ...createEmptyStats(),\n    startTs: startTs ?? 0,\n    total,\n  },\n})\n\nconst createEmptyMicrowaveReport = (projectName: string, startTs?: number): MicrowaveReportJson => ({\n  suites: [],\n  stats: {\n    ...createEmptyStats(),\n    startTs: startTs ?? 0,\n  },\n  projectName,\n})\n\nexport class TestCaseSummary implements ITestCaseSummary {\n  public results: TestCaseSummaryResults\n  private timer: MicrowaveTimer\n\n  public constructor(order?: number, description?: string, suiteName?: string) {\n    this.timer = new MicrowaveTimer()\n    this.results = createEmptyTestCaseResults(order, description, suiteName, this.timer.startTs)\n  }\n\n  public processTestCaseResults(testCaseResults: {\n    e?: string\n    name?: string\n    status: TestCaseSummaryResults[\"status\"]\n    retries?: number\n  }): void {\n    this.results.errors = testCaseResults.e ? [testCaseResults.e] : []\n    this.results.status = testCaseResults.status\n    this.results.ok = testCaseResults.status === \"passed\"\n    this.results.retry = testCaseResults.retries ?? 0\n    this.finalizeSummary()\n  }\n\n  public finalizeSummary(): void {\n    this.timer.stopTimer()\n    this.results.finishTs = this.timer.finishTs ?? 0\n    this.results.duration = this.timer.duration ?? 0\n  }\n\n  public toJson(): TestCaseSummaryResults {\n    return {\n      ...this.results,\n    }\n  }\n}\n\nexport class TestSuiteSummary implements ITestSuiteSummary {\n  public summary: TestSuiteSummaryResults\n  private timer: MicrowaveTimer\n\n  constructor(suiteName: string = \"\", suiteOrder = 0, total = 0) {\n    this.timer = new MicrowaveTimer()\n    this.summary = createEmptyTestSuiteResults(suiteName, suiteOrder, total, this.timer.startTs)\n  }\n\n  public processTestCaseResultsSummary(testCaseSummary: ITestCaseSummary): void {\n    const testCase = testCaseSummary.toJson()\n    this.summary.tests.push(testCase)\n    this.summary.stats.passed += testCase.ok ? 1 : 0\n    this.summary.stats.failed += testCase.ok ? 0 : 1\n    this.summary.stats.skipped += testCase.status === \"skipped\" ? 1 : 0\n    this.summary.stats.ok = this.summary.stats.failed === 0\n  }\n\n  public finalizeSummary(): void {\n    this.timer.stopTimer()\n    this.summary.stats.finishTs = this.timer.finishTs ?? 0\n    this.summary.stats.duration = this.timer.duration ?? 0\n  }\n\n  public toJson(): TestSuiteSummaryResults {\n    return {\n      ...this.summary,\n    }\n  }\n}\n\nexport class MicrowaveReport {\n  public report: MicrowaveReportJson\n  private timer: MicrowaveTimer\n\n  public constructor(projectName?: string) {\n    this.timer = new MicrowaveTimer()\n    this.report = createEmptyMicrowaveReport(projectName ?? \"\", this.timer.startTs)\n  }\n\n  public processTestSuiteSummary(testSuiteSummary: ITestSuiteSummary): void {\n    const suite = testSuiteSummary.toJson()\n    this.report.suites.push(suite)\n    this.report.stats.total += suite.stats.total\n    this.report.stats.passed += suite.stats.passed\n    this.report.stats.failed += suite.stats.failed\n    this.report.stats.skipped += suite.stats.skipped\n    this.report.stats.ok = this.report.stats.failed === 0\n  }\n\n  public finalizeReport(): void {\n    this.timer.stopTimer()\n    this.report.stats.finishTs = this.timer.finishTs ?? 0\n    this.report.stats.duration = this.timer.duration ?? 0\n  }\n\n  public toJson(): MicrowaveReportJson {\n    return {\n      ...this.report,\n    }\n  }\n}\n","import type {\n  RegisterTestCase,\n  RegisterHook,\n  RegisterExclusion,\n  MicrowaveTestCallback,\n  MicrowaveHook,\n  IMicrowaveSuite,\n} from \"./types\"\n\nexport class MicrowaveSuite implements IMicrowaveSuite {\n  public suiteName: string\n  public isRegistered: boolean = false\n  public registerTestCase: RegisterTestCase\n  public registerHook: RegisterHook\n  public registerExclusion: RegisterExclusion\n\n  public static create(\n    suiteName: string = \"\",\n    registerTestCase: RegisterTestCase,\n    registerHook: RegisterHook,\n    registerExclusion: RegisterExclusion\n  ) {\n    const microwaveSuite = new MicrowaveSuite(suiteName, registerTestCase, registerHook, registerExclusion)\n    microwaveSuite.before.each = microwaveSuite.beforeEach\n    microwaveSuite.after.each = microwaveSuite.afterEach\n    return microwaveSuite\n  }\n\n  private constructor(\n    suiteName: string = \"\",\n    registerTestCase: RegisterTestCase,\n    registerHook: RegisterHook,\n    registerExclusion: RegisterExclusion\n  ) {\n    this.suiteName = suiteName\n    this.registerTestCase = registerTestCase\n    this.registerHook = registerHook\n    this.registerExclusion = registerExclusion\n  }\n\n  public test = (description: string, test: MicrowaveTestCallback) => {\n    this.registerTestCase(this.suiteName, { description, test })\n  }\n\n  public before: MicrowaveHook = (cb: MicrowaveTestCallback) => {\n    this.registerHook(this.suiteName, \"before\", cb)\n  }\n\n  public beforeEach = (cb: MicrowaveTestCallback) => {\n    this.registerHook(this.suiteName, \"beforeEach\", cb)\n  }\n\n  public after: MicrowaveHook = (cb: MicrowaveTestCallback) => {\n    this.registerHook(this.suiteName, \"after\", cb)\n  }\n\n  public afterEach = (cb: MicrowaveTestCallback) => {\n    this.registerHook(this.suiteName, \"afterEach\", cb)\n  }\n\n  public only = (description: string, test: MicrowaveTestCallback) => {\n    this.registerExclusion(this.suiteName, \"only\", { description, test })\n  }\n\n  public skip = (description: string, test: MicrowaveTestCallback) => {\n    this.registerExclusion(this.suiteName, \"skip\", { description, test })\n  }\n\n  public run = () => {\n    this.isRegistered = true\n    return this\n  }\n}\n","import type {\n  MicrowaveConfig,\n  IMicrowaveReport,\n  MicrowaveSuiteHooks,\n  MicrowaveSuiteHookType,\n  MicrowaveSuiteExclusions,\n  MicrowaveContext,\n  MicrowaveTestCallback,\n  TestCaseResultsStatus,\n  SuiteName,\n  SuitesMapping,\n  MicrowaveSuiteStore,\n  IMicrowaveSuite,\n} from \"./types\"\nimport { format } from \"./utils\"\nimport { MicrowaveReport, TestSuiteSummary, TestCaseSummary } from \"./report\"\nimport { MicrowaveSuite } from \"./suite\"\n\nconst createDefaultSuiteHooks = (): MicrowaveSuiteHooks => ({\n  before: [],\n  after: [],\n  beforeEach: [],\n  afterEach: [],\n})\n\nconst createDefaultSuiteExclusions = (): MicrowaveSuiteExclusions => ({\n  only: [],\n  skip: [],\n})\n\nconst createDefaultContext = <T = MicrowaveContext>(ctx: T): T => ctx\n\nconst createDefaultMicrowaveSuiteStore = <T = MicrowaveContext>(\n  numSuites: number,\n  newSuite: IMicrowaveSuite,\n  ctx: T\n): MicrowaveSuiteStore<T> => ({\n  ctx: createDefaultContext(ctx),\n  order: numSuites,\n  suite: newSuite,\n  tests: [],\n  hasOnly: false,\n  ...createDefaultSuiteHooks(),\n  ...createDefaultSuiteExclusions(),\n})\n\nconst defaultMicrowaveConfig = {\n  appName: \"Test Project\",\n  verbose: false,\n  reporters: {\n    html: true,\n    console: false,\n    json: false,\n  },\n}\n\nexport class Microwave {\n  private isRunning: boolean = false\n  public config?: MicrowaveConfig = { ...defaultMicrowaveConfig }\n  public appName?: string\n  public MICROWAVE_SUITES: SuitesMapping = {}\n  public MICROWAVE_SUITE_ORDER: SuiteName[] = []\n  public MICROWAVE_SUITE_QUEUE: SuiteName[][] = []\n\n  private constructor() {\n    this.appName = defaultMicrowaveConfig.appName\n    this.registerTestCase = this.registerTestCase.bind(this)\n    this.registerHook = this.registerHook.bind(this)\n    this.registerExclusion = this.registerExclusion.bind(this)\n  }\n\n  public static create() {\n    const microwave = new Microwave()\n    return microwave\n  }\n\n  public updateConfig(config: MicrowaveConfig) {\n    this.config = config\n    this.appName = config.appName ?? this.appName\n  }\n\n  public registerTestCase(suiteName: string, testCase: { description: string; test: MicrowaveTestCallback }) {\n    const suite = this.getMostRecentSuite(suiteName)\n    if (suite) return suite.tests.push(testCase)\n\n    if (this.config?.verbose)\n      console.warn(\n        `Attempted to register test case: ${testCase.description} hook for suite ${suiteName} that doesn't exist.`\n      )\n  }\n\n  public registerHook(suiteName: string, hookType: MicrowaveSuiteHookType, cb: MicrowaveTestCallback) {\n    const suite = this.getMostRecentSuite(suiteName)\n    if (suite) return suite[hookType].push(cb)\n\n    if (this.config?.verbose)\n      console.warn(`Attempted to register ${hookType} hook for suite ${suiteName} that doesn't exist.`)\n  }\n\n  public registerExclusion(\n    suiteName: string,\n    exclusionType: \"skip\" | \"only\",\n    testCase: { description: string; test: MicrowaveTestCallback }\n  ) {\n    const suite = this.getMostRecentSuite(suiteName)\n    if (suite) return suite[exclusionType].push(testCase)\n\n    if (this.config?.verbose)\n      console.warn(`Attempted to register test.${exclusionType} for suite ${suiteName} that doesn't exist.`)\n  }\n\n  public suite = (suiteName: string = \"\") => {\n    if (!suiteName) return console.warn(`All test suites need a name. Skipping.`)\n\n    const numSuites = Object.keys(this.MICROWAVE_SUITES).length\n    const newSuite = MicrowaveSuite.create(suiteName, this.registerTestCase, this.registerHook, this.registerExclusion)\n\n    let mostRecentQueue = this.getMostRecentlyAddedSuiteQueue()\n    // if no current queues exist, or if the most recent one already has this suite,\n    // create a new queue with this suite as the first one\n    if (!mostRecentQueue || mostRecentQueue.includes(suiteName)) {\n      mostRecentQueue = [suiteName]\n      this.MICROWAVE_SUITE_QUEUE.push(mostRecentQueue)\n    } else {\n      mostRecentQueue.push(suiteName)\n    }\n\n    const ctx = { __suite__: suiteName, __test__: \"\" }\n    if (!Array.isArray(this.MICROWAVE_SUITES[suiteName])) {\n      this.MICROWAVE_SUITES[suiteName] = []\n    }\n    this.MICROWAVE_SUITES[suiteName].push(createDefaultMicrowaveSuiteStore(numSuites, newSuite, ctx))\n\n    return newSuite\n  }\n\n  public deferredExec = async (deferMs = 25): Promise<IMicrowaveReport> => {\n    return new Promise((resolve) => {\n      setTimeout(async () => {\n        const report = await this.exec()\n        resolve(report)\n      }, deferMs)\n    })\n  }\n\n  public exec = async (): Promise<IMicrowaveReport> => {\n    if (this.isRunning) return await this.deferredExec()\n\n    if (this.config?.verbose) console.log(\"Executing tests...\")\n    this.isRunning = true\n\n    // start timer\n    const report = new MicrowaveReport(this.appName)\n\n    // get the ordered list of suites to execute from the queue\n    if (!this.MICROWAVE_SUITE_QUEUE.length) {\n      if (this.config?.verbose) console.warn(\"No test suites registered yet. Skipping execution.\")\n      return report\n    }\n    const suiteNames = this.MICROWAVE_SUITE_QUEUE.shift() as SuiteName[]\n\n    // extract the actual test suites\n    const suitesToExec: MicrowaveSuiteStore[] = []\n    for (const suiteName of suiteNames) {\n      if (this.MICROWAVE_SUITES[suiteName]?.length) {\n        const suite: MicrowaveSuiteStore = this.MICROWAVE_SUITES[suiteName].shift() as MicrowaveSuiteStore\n        suitesToExec.push(suite)\n        // purge this suite if nothing left in the queue\n        if (!this.MICROWAVE_SUITES[suiteName].length) {\n          delete this.MICROWAVE_SUITES[suiteName]\n        }\n      } else {\n        if (this.config?.verbose) console.warn(`No suite found for '${suiteName}'`)\n      }\n    }\n\n    // check for any onlys\n    let runOnly = false\n    for (const suite of suitesToExec) {\n      if (suite.only.length) {\n        runOnly = true\n        break\n      }\n    }\n\n    // reuse variable for iterating over hooks\n    let hook: any\n    for (const existingTestSuite of suitesToExec) {\n      const { suite, order, tests, ctx } = existingTestSuite\n      // get hooks\n      const { before, beforeEach, after, afterEach } = existingTestSuite\n      // get exclusions\n      const { only, skip } = existingTestSuite\n      const skipMapping = skip.reduce((acc, curr) => {\n        return { ...acc, [curr.description]: true }\n      }, {})\n      // filter tests to run when dealing with onlys\n      const testsToRun = runOnly ? only : tests\n\n      // start suite timer\n      const testSuiteSummary = new TestSuiteSummary(suite.suiteName, order, tests.length)\n\n      if (testsToRun.length) {\n        // run before hooks\n        for (hook of before) await hook(ctx)\n\n        for (let testCaseOrder = 0; testCaseOrder < testsToRun.length; testCaseOrder++) {\n          const testCase = testsToRun[testCaseOrder]\n          // start timer\n          const testCaseSummary = new TestCaseSummary(testCaseOrder, testCase.description, suite.suiteName)\n          let results = {\n            e: undefined as undefined | string,\n            retries: 0,\n            status: \"passed\" as TestCaseResultsStatus,\n            name: testCase.description,\n          }\n\n          // if need to skip it...\n          if (skipMapping[testCase.description as keyof typeof skipMapping]) {\n            // short circuit that thang\n            results.status = \"skipped\"\n            testCaseSummary.processTestCaseResults(results)\n            testSuiteSummary.processTestCaseResultsSummary(testCaseSummary)\n            continue\n          }\n\n          // run beforeEach hooks\n          for (hook of beforeEach) await hook(ctx)\n\n          try {\n            await testCase.test(ctx)\n          } catch (e) {\n            results.e = format(testCase.description, e, suite.suiteName)\n            results.status = \"failed\"\n          } finally {\n            // finish test case timer\n            testCaseSummary.processTestCaseResults(results)\n            testSuiteSummary.processTestCaseResultsSummary(testCaseSummary)\n          }\n\n          // run afterEach hooks\n          for (hook of afterEach) await hook(ctx)\n        }\n\n        // run after hooks\n        for (hook of after) await hook(ctx)\n      }\n      // finalize test suite timer\n      testSuiteSummary.finalizeSummary()\n      // process test suite results\n      report.processTestSuiteSummary(testSuiteSummary)\n      report.finalizeReport()\n    }\n\n    if (this.config?.verbose) console.log(\"Finished executing tests\")\n\n    this.isRunning = false\n\n    return report\n  }\n\n  /*============================================================\n                        PRIVATE METHODS\n   ============================================================*/\n\n  private getMostRecentSuite(suiteName: string): MicrowaveSuiteStore | null {\n    const suiteArray = this.MICROWAVE_SUITES[suiteName]\n    return Array.isArray(suiteArray) ? suiteArray[suiteArray.length - 1] : null\n  }\n\n  private getMostRecentlyAddedSuiteQueue(): SuiteName[] {\n    return this.MICROWAVE_SUITE_QUEUE[this.MICROWAVE_SUITE_QUEUE.length - 1]\n  }\n}\n\nconst microwave = Microwave.create()\nexport const updateConfig = (config: MicrowaveConfig) => microwave.updateConfig(config)\nexport const suite = microwave.suite\nexport const test = () => suite()\nexport const exec = microwave.exec\n"],"mappings":"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","names":[]}