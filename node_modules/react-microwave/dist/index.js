var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  assert: () => assert_exports,
  exec: () => exec,
  suite: () => suite,
  test: () => test,
  updateConfig: () => updateConfig
});
module.exports = __toCommonJS(src_exports);

// src/microwave/assert.ts
var assert_exports = {};
__export(assert_exports, {
  Assertion: () => Assertion,
  equal: () => equal,
  fixture: () => fixture,
  instance: () => instance,
  is: () => is,
  match: () => match,
  not: () => not,
  ok: () => ok,
  snapshot: () => snapshot,
  throws: () => throws,
  type: () => type,
  unreachable: () => unreachable
});
var import_dequal = require("dequal");

// src/microwave/diff.ts
var diff = __toESM(require("diff"));
var HTMLColoredFormatter = {
  "--": (str) => `<span class="html-colored-formatter diff-removed red" style="color: var(--color-scale-red-5)">${str}</span>`,
  "\xB7\xB7": (str) => `<span class="html-colored-formatter diff-stayed grey" style="color: var(--color-scale-gray-4)">${str}</span>`,
  "++": (str) => `<span class="html-colored-formatter diff-added green" style="color: var(--color-scale-green-4)">${str}</span>`,
  TITLE: (str) => `<span class="html-colored-formatter title italic">${str}</span>`,
  TAB: (str) => `<span class="html-colored-formatter tab dim">${str}</span>`,
  DIM: (str) => `<span class="html-colored-formatter dim">${str}</span>`,
  dim: (str) => `<span class="html-colored-formatter dim">${str}</span>`,
  SPACE: (str) => `<span class="html-colored-formatter space dim">${str}</span>`,
  NL: (str) => `<span class="html-colored-formatter new-line dim">${str}</span>`,
  UNDERLINE: (str) => `<span class="html-colored-formatter underline">${str}</span>`,
  underline: (str) => `<span class="html-colored-formatter underline">${str}</span>`
};
var HTMLLOG = (sym, str) => sym + HTMLPRETTY(str) + "\n\n";
var HTMLLINE = (num, x) => "L" + String(num).padStart(x, "0") + " ";
var HTMLPRETTY = (str) => {
  const prettifiedString = str.replace(/[ ]/g, "&nbsp;").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/(\r?\n)/g, "<br /><br />");
  return `<span class="pretty">${prettifiedString}</span>`;
};
function line(obj, prev, pad) {
  let char = obj.removed ? "--" : obj.added ? "++" : "\xB7\xB7";
  let arr = obj.value.replace(/\r?\n$/, "").split("\n");
  let i = 0;
  let tmp;
  let out = "";
  if (obj.added)
    out += "Expected:\n";
  else if (obj.removed)
    out += "Actual:\n";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    if (tmp != null) {
      if (prev)
        out += HTMLLINE(prev + i, pad);
      out += HTMLLOG(char, tmp || "\n");
    }
  }
  return out;
}
function lines(input, expect, linenum = 0) {
  let i = 0;
  let tmp;
  let output = "";
  let arr = diff.diffLines(input, expect);
  let pad = String(expect.split(/\r?\n/g).length - linenum).length;
  for (; i < arr.length; i++) {
    output += line(tmp = arr[i], linenum, pad);
    if (linenum && !tmp.removed)
      linenum += tmp?.count ?? 0;
  }
  return output;
}
function circular() {
  const cache = /* @__PURE__ */ new Set();
  return function print(key, val) {
    if (val === void 0)
      return "[__VOID__]";
    if (typeof val === "number" && val !== val)
      return "[__NAN__]";
    if (!val || typeof val !== "object")
      return val;
    if (cache.has(val))
      return "[Circular]";
    cache.add(val);
    return val;
  };
}
function stringify(input) {
  return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, "NaN").replace(/"\[__VOID__\]"/g, "undefined");
}
function arrays(input, expect) {
  let arr = diff.diffArrays(input, expect);
  let i = 0;
  let j = 0;
  let k = 0;
  let tmp;
  let val;
  let char;
  let isObj;
  let str;
  let out = HTMLLOG("\xB7\xB7", "[");
  for (; i < arr.length; i++) {
    char = (tmp = arr[i]).removed ? "--" : tmp.added ? "++" : "\xB7\xB7";
    if (tmp.added) {
      out += HTMLColoredFormatter[char](HTMLColoredFormatter.underline(HTMLColoredFormatter.TITLE("Expected:")) + "\n");
    } else if (tmp.removed) {
      out += HTMLColoredFormatter[char](HTMLColoredFormatter.underline(HTMLColoredFormatter.TITLE("Actual:")) + "\n");
    }
    for (j = 0; j < tmp.value.length; j++) {
      isObj = tmp.value[j] && typeof tmp.value[j] === "object";
      val = stringify(tmp.value[j]).split(/\r?\n/g);
      for (k = 0; k < val.length; ) {
        str = "  " + val[k++] + (isObj ? "" : ",");
        if (isObj && k === val.length && j + 1 < tmp.value.length)
          str += ",";
        out += HTMLLOG(char, str);
      }
    }
  }
  return out + HTMLLOG("\xB7\xB7", "]");
}
function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {
  let gutter = 4;
  let lenC = Math.max(lenA, lenB);
  let typeA = typeof input;
  let typeB = typeof expect;
  if (typeA !== typeB) {
    gutter = 2;
    let delA = gutter + lenC - lenA;
    let delB = gutter + lenC - lenB;
    input += " ".repeat(delA) + HTMLColoredFormatter.dim(`[${typeA}]`);
    expect += " ".repeat(delB) + HTMLColoredFormatter.dim(`[${typeB}]`);
    lenA += delA + typeA.length + 2;
    lenB += delB + typeB.length + 2;
    lenC = Math.max(lenA, lenB);
  }
  let output = HTMLColoredFormatter["++"]("++" + expect + " ".repeat(gutter + lenC - lenB) + HTMLColoredFormatter.TITLE("(Expected)")) + "\n";
  return output + HTMLColoredFormatter["--"]("--" + input + " ".repeat(gutter + lenC - lenA) + HTMLColoredFormatter.TITLE("(Actual)")) + "\n";
}
function chars(input, expect) {
  let arr = diff.diffChars(input, expect);
  let i = 0;
  let output = "";
  let tmp;
  let l1 = input.length;
  let l2 = expect.length;
  let p1 = HTMLPRETTY(input);
  let p2 = HTMLPRETTY(expect);
  tmp = arr[i];
  if (l1 === l2) {
  } else if (tmp.removed && arr[i + 1]) {
    let del = (tmp?.count ?? 0) - (arr[i + 1].count ?? 0);
    if (del == 0) {
    } else if (del > 0) {
      expect = " ".repeat(del) + expect;
      p2 = " ".repeat(del) + p2;
      l2 += del;
    } else if (del < 0) {
      input = " ".repeat(-del) + input;
      p1 = " ".repeat(-del) + p1;
      l1 += -del;
    }
  }
  output += direct(p1, p2, l1, l2);
  if (l1 === l2) {
    for (tmp = "  "; i < l1; i++) {
      tmp += input[i] === expect[i] ? " " : "^";
    }
  } else {
    for (tmp = "  "; i < arr.length; i++) {
      tmp += (arr[i].added || arr[i].removed ? "^" : " ").repeat(Math.max(arr[i]?.count ?? 0, 0));
      if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {
        ;
        arr[i + 1].count -= arr[i]?.count ?? 0;
      }
    }
  }
  return output + tmp;
}
function sort(input, expect) {
  var k;
  var i = 0;
  var tmp;
  var isArr = Array.isArray(input);
  var keys = [];
  var out = isArr ? Array(input.length) : {};
  if (isArr) {
    for (i = 0; i < (out?.length ?? 0); i++) {
      tmp = input[i];
      if (!tmp || typeof tmp !== "object") {
        out[i] = tmp;
      } else {
        out[i] = sort(tmp, expect[i]);
      }
    }
  } else {
    for (k in expect)
      keys.push(k);
    for (; i < keys.length; i++) {
      if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {
        if (!(tmp = input[k]) || typeof tmp !== "object")
          out[k] = tmp;
        else
          out[k] = sort(tmp, expect[k]);
      }
    }
    for (k in input) {
      if (!out.hasOwnProperty(k)) {
        out[k] = input[k];
      }
    }
  }
  return out;
}
function compare(input, expect) {
  if (Array.isArray(expect) && Array.isArray(input))
    return arrays(input, expect);
  if (expect instanceof RegExp)
    return chars("" + input, "" + expect);
  let isA = input && typeof input == "object";
  let isB = expect && typeof expect == "object";
  if (isA && isB)
    input = sort(input, expect);
  if (isB)
    expect = stringify(expect);
  if (isA)
    input = stringify(input);
  if (expect && typeof expect == "object") {
    input = stringify(sort(input, expect));
    expect = stringify(expect);
  }
  isA = typeof input == "string";
  isB = typeof expect == "string";
  if (isA && /\r?\n/.test(input))
    return lines(input, "" + expect);
  if (isB && /\r?\n/.test(expect))
    return lines("" + input, expect);
  if (isA && isB)
    return chars(input, expect);
  return direct(input, expect);
}

// src/microwave/utils.ts
var GUTTER = "\n        ";
var IGNORE = /^\s*at.*(?:\(|\s)(?:node|(internal\/[\w/]*))/;
function stack(stack2, idx) {
  let i = 0;
  let line2;
  let out = "";
  let arr = stack2.substring(idx).replace(/\\/g, "/").split("\n");
  for (; i < arr.length; i++) {
    line2 = arr[i].trim();
    if (line2.length && !IGNORE.test(line2)) {
      out += "\n    " + line2;
    }
  }
  return out + "\n";
}
var format = (name, err, suite2 = "") => {
  let { details, operator = "" } = err;
  let idx = err.stack && err.stack.indexOf("\n");
  if (err.name.startsWith("AssertionError") && !operator.includes("not"))
    details = compare(err.actual, err.expected);
  let htmlStr = `<span>`;
  htmlStr += `<span class="error-text suite-name">${` \u2718  ${suite2} >>> \u{1F680} `}</span>`;
  htmlStr += `<span class="error-text test-name">${name}</span>`;
  htmlStr += `</span>`;
  htmlStr += "\n    " + err.message + (operator ? `  (${operator})` : "") + "\n";
  if (details)
    htmlStr += GUTTER + details.split("\n").join(GUTTER);
  if (!!~idx)
    htmlStr += stack(err.stack, idx);
  return htmlStr + "\n";
};
function dedent(str) {
  str = str.replace(/\r?\n/g, "\n");
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let i = 0;
  let min = 1 / 0;
  let len = (arr || []).length;
  for (; i < len; i++)
    min = Math.min(min, arr?.[i]?.length ?? Number.POSITIVE_INFINITY);
  return len && min ? str.replace(new RegExp(`^[ \\t]{${min}}`, "gm"), "") : str;
}

// src/microwave/assert.ts
var Assertion = class extends Error {
  name;
  code;
  details;
  generated;
  operator;
  expects;
  actual;
  constructor(opts) {
    super(opts.message ?? "");
    this.name = "Assertion";
    this.code = "ERR_ASSERTION";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.details = opts?.details || false;
    this.generated = !!opts?.generated;
    this.operator = opts?.operator;
    this.expects = opts?.expects;
    this.actual = opts?.actual;
  }
};
function assert(bool, actual, expects, operator, detailer, backup, msg) {
  if (bool)
    return;
  let message = msg || backup;
  if (msg instanceof Error)
    throw msg;
  let details = detailer && detailer(actual, expects);
  throw new Assertion({
    actual,
    expects,
    operator,
    message,
    details: details ?? false,
    generated: !msg
  });
}
function ok(val, msg) {
  assert(!!val, false, true, "ok", false, "Expected value to be truthy", msg);
}
function is(val, exp, msg) {
  assert(val === exp, val, exp, "is", compare, "Expected values to be strictly equal:", msg);
}
function equal(val, exp, msg) {
  assert((0, import_dequal.dequal)(val, exp), val, exp, "equal", compare, "Expected values to be deeply equal:", msg);
}
function unreachable(msg) {
  assert(false, true, false, "unreachable", false, "Expected not to be reached!", msg);
}
function type(val, exp, msg) {
  let tmp = typeof val;
  assert(tmp === exp, tmp, exp, "type", false, `Expected "${tmp}" to be "${exp}"`, msg);
}
function instance(val, exp, msg) {
  let name = "`" + (exp.name || exp.constructor.name) + "`";
  assert(val instanceof exp, val, exp, "instance", false, `Expected value to be an instance of ${name}`, msg);
}
function match(val, exp, msg) {
  if (typeof exp === "string") {
    assert(val.includes(exp), val, exp, "match", false, `Expected value to include "${exp}" substring`, msg);
  } else {
    assert(exp.test(val), val, exp, "match", false, `Expected value to match \`${String(exp)}\` pattern`, msg);
  }
}
function snapshot(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val === exp, val, exp, "snapshot", lines, "Expected value to match snapshot:", msg);
}
var lineNums = (x, y) => lines(x, y, 1);
function fixture(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val === exp, val, exp, "fixture", lineNums, "Expected value to match fixture:", msg);
}
function throws(blk, exp, msg) {
  if (!msg && typeof exp === "string") {
    msg = exp;
    exp = null;
  }
  try {
    blk();
    assert(false, false, true, "throws", false, "Expected function to throw", msg);
  } catch (err) {
    if (err instanceof Assertion)
      throw err;
    if (typeof exp === "function") {
      assert(exp(err), false, true, "throws", false, "Expected function to throw matching exception", msg);
    } else if (exp instanceof RegExp) {
      assert(exp.test(err.message), false, true, "throws", false, `Expected function to throw exception matching \`${String(exp)}\` pattern`, msg);
    }
  }
}
function not(val, msg) {
  assert(!val, true, false, "not", false, "Expected value to be falsey", msg);
}
not.ok = not;
is.not = function(val, exp, msg) {
  assert(val !== exp, val, exp, "is.not", false, "Expected values not to be strictly equal", msg);
};
not.equal = function(val, exp, msg) {
  assert(!(0, import_dequal.dequal)(val, exp), val, exp, "not.equal", false, "Expected values not to be deeply equal", msg);
};
not.type = function(val, exp, msg) {
  let tmp = typeof val;
  assert(tmp !== exp, tmp, exp, "not.type", false, `Expected "${tmp}" not to be "${exp}"`, msg);
};
not.instance = function(val, exp, msg) {
  let name = "`" + (exp.name || exp.constructor.name) + "`";
  assert(!(val instanceof exp), val, exp, "not.instance", false, `Expected value not to be an instance of ${name}`, msg);
};
not.snapshot = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.snapshot", false, "Expected value not to match snapshot", msg);
};
not.fixture = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.fixture", false, "Expected value not to match fixture", msg);
};
not.match = function match2(val, exp, msg) {
  if (typeof exp === "string") {
    assert(!val.includes(exp), val, exp, "not.match", false, `Expected value not to include "${exp}" substring`, msg);
  } else {
    assert(!exp.test(val), val, exp, "not.match", false, `Expected value not to match \`${String(exp)}\` pattern`, msg);
  }
};
not.throws = function(blk, exp, msg) {
  if (!msg && typeof exp === "string") {
    msg = exp;
    exp = null;
  }
  try {
    blk();
  } catch (err) {
    if (typeof exp === "function") {
      assert(!exp(err), true, false, "not.throws", false, "Expected function not to throw matching exception", msg);
    } else if (exp instanceof RegExp) {
      assert(!exp.test(err.message), true, false, "not.throws", false, `Expected function not to throw exception matching \`${String(exp)}\` pattern`, msg);
    } else if (!exp) {
      assert(false, true, false, "not.throws", false, "Expected function not to throw", msg);
    }
  }
};

// src/microwave/timer.ts
var MicrowaveTimer = class {
  startTs;
  finishTs;
  duration;
  stopTimer;
  constructor(now, formatted = false) {
    const { start, timer } = this.createTimer(now ?? this.getNow(), formatted);
    this.startTs = start;
    this.stopTimer = timer;
  }
  getNow() {
    return typeof performance < "u" ? performance.now() : Date.now();
  }
  createTimer(now = this.getNow(), formatted = false) {
    return {
      start: now,
      timer: () => {
        this.finishTs = this.getNow();
        this.duration = this.finishTs - now;
        return formatted ? this.duration.toFixed(2) + "ms" : this.duration;
      }
    };
  }
};

// src/microwave/report.ts
var createEmptyStats = () => ({
  total: 0,
  passed: 0,
  failed: 0,
  skipped: 0,
  ok: true,
  duration: 0,
  startTs: 0,
  finishTs: 0
});
var createEmptyTestCaseResults = (order, description, suiteName, startTs) => ({
  order: order ?? -1,
  description: description ?? "",
  suiteName: suiteName ?? "",
  annotations: [],
  ok: true,
  retry: 0,
  errors: [],
  status: "passed",
  startTs: startTs ?? 0,
  finishTs: 0,
  duration: 0
});
var createEmptyTestSuiteResults = (suiteName, suiteOrder, total, startTs) => ({
  suiteName,
  suiteOrder,
  tests: [],
  stats: {
    ...createEmptyStats(),
    startTs: startTs ?? 0,
    total
  }
});
var createEmptyMicrowaveReport = (projectName, startTs) => ({
  suites: [],
  stats: {
    ...createEmptyStats(),
    startTs: startTs ?? 0
  },
  projectName
});
var TestCaseSummary = class {
  results;
  timer;
  constructor(order, description, suiteName) {
    this.timer = new MicrowaveTimer();
    this.results = createEmptyTestCaseResults(order, description, suiteName, this.timer.startTs);
  }
  processTestCaseResults(testCaseResults) {
    this.results.errors = testCaseResults.e ? [testCaseResults.e] : [];
    this.results.status = testCaseResults.status;
    this.results.ok = testCaseResults.status === "passed";
    this.results.retry = testCaseResults.retries ?? 0;
    this.finalizeSummary();
  }
  finalizeSummary() {
    this.timer.stopTimer();
    this.results.finishTs = this.timer.finishTs ?? 0;
    this.results.duration = this.timer.duration ?? 0;
  }
  toJson() {
    return {
      ...this.results
    };
  }
};
var TestSuiteSummary = class {
  summary;
  timer;
  constructor(suiteName = "", suiteOrder = 0, total = 0) {
    this.timer = new MicrowaveTimer();
    this.summary = createEmptyTestSuiteResults(suiteName, suiteOrder, total, this.timer.startTs);
  }
  processTestCaseResultsSummary(testCaseSummary) {
    const testCase = testCaseSummary.toJson();
    this.summary.tests.push(testCase);
    this.summary.stats.passed += testCase.ok ? 1 : 0;
    this.summary.stats.failed += testCase.ok ? 0 : 1;
    this.summary.stats.skipped += testCase.status === "skipped" ? 1 : 0;
    this.summary.stats.ok = this.summary.stats.failed === 0;
  }
  finalizeSummary() {
    this.timer.stopTimer();
    this.summary.stats.finishTs = this.timer.finishTs ?? 0;
    this.summary.stats.duration = this.timer.duration ?? 0;
  }
  toJson() {
    return {
      ...this.summary
    };
  }
};
var MicrowaveReport = class {
  report;
  timer;
  constructor(projectName) {
    this.timer = new MicrowaveTimer();
    this.report = createEmptyMicrowaveReport(projectName ?? "", this.timer.startTs);
  }
  processTestSuiteSummary(testSuiteSummary) {
    const suite2 = testSuiteSummary.toJson();
    this.report.suites.push(suite2);
    this.report.stats.total += suite2.stats.total;
    this.report.stats.passed += suite2.stats.passed;
    this.report.stats.failed += suite2.stats.failed;
    this.report.stats.skipped += suite2.stats.skipped;
    this.report.stats.ok = this.report.stats.failed === 0;
  }
  finalizeReport() {
    this.timer.stopTimer();
    this.report.stats.finishTs = this.timer.finishTs ?? 0;
    this.report.stats.duration = this.timer.duration ?? 0;
  }
  toJson() {
    return {
      ...this.report
    };
  }
};

// src/microwave/suite.ts
var MicrowaveSuite = class {
  suiteName;
  isRegistered = false;
  registerTestCase;
  registerHook;
  registerExclusion;
  static create(suiteName = "", registerTestCase, registerHook, registerExclusion) {
    const microwaveSuite = new MicrowaveSuite(suiteName, registerTestCase, registerHook, registerExclusion);
    microwaveSuite.before.each = microwaveSuite.beforeEach;
    microwaveSuite.after.each = microwaveSuite.afterEach;
    return microwaveSuite;
  }
  constructor(suiteName = "", registerTestCase, registerHook, registerExclusion) {
    this.suiteName = suiteName;
    this.registerTestCase = registerTestCase;
    this.registerHook = registerHook;
    this.registerExclusion = registerExclusion;
  }
  test = (description, test2) => {
    this.registerTestCase(this.suiteName, { description, test: test2 });
  };
  before = (cb) => {
    this.registerHook(this.suiteName, "before", cb);
  };
  beforeEach = (cb) => {
    this.registerHook(this.suiteName, "beforeEach", cb);
  };
  after = (cb) => {
    this.registerHook(this.suiteName, "after", cb);
  };
  afterEach = (cb) => {
    this.registerHook(this.suiteName, "afterEach", cb);
  };
  only = (description, test2) => {
    this.registerExclusion(this.suiteName, "only", { description, test: test2 });
  };
  skip = (description, test2) => {
    this.registerExclusion(this.suiteName, "skip", { description, test: test2 });
  };
  run = () => {
    this.isRegistered = true;
    return this;
  };
};

// src/microwave/index.ts
var createDefaultSuiteHooks = () => ({
  before: [],
  after: [],
  beforeEach: [],
  afterEach: []
});
var createDefaultSuiteExclusions = () => ({
  only: [],
  skip: []
});
var createDefaultContext = (ctx) => ctx;
var createDefaultMicrowaveSuiteStore = (numSuites, newSuite, ctx) => ({
  ctx: createDefaultContext(ctx),
  order: numSuites,
  suite: newSuite,
  tests: [],
  hasOnly: false,
  ...createDefaultSuiteHooks(),
  ...createDefaultSuiteExclusions()
});
var defaultMicrowaveConfig = {
  appName: "Test Project",
  verbose: false,
  reporters: {
    html: true,
    console: false,
    json: false
  }
};
var Microwave = class {
  isRunning = false;
  config = { ...defaultMicrowaveConfig };
  appName;
  MICROWAVE_SUITES = {};
  MICROWAVE_SUITE_ORDER = [];
  MICROWAVE_SUITE_QUEUE = [];
  constructor() {
    this.appName = defaultMicrowaveConfig.appName;
    this.registerTestCase = this.registerTestCase.bind(this);
    this.registerHook = this.registerHook.bind(this);
    this.registerExclusion = this.registerExclusion.bind(this);
  }
  static create() {
    const microwave2 = new Microwave();
    return microwave2;
  }
  updateConfig(config) {
    this.config = config;
    this.appName = config.appName ?? this.appName;
  }
  registerTestCase(suiteName, testCase) {
    const suite2 = this.getMostRecentSuite(suiteName);
    if (suite2)
      return suite2.tests.push(testCase);
    if (this.config?.verbose)
      console.warn(`Attempted to register test case: ${testCase.description} hook for suite ${suiteName} that doesn't exist.`);
  }
  registerHook(suiteName, hookType, cb) {
    const suite2 = this.getMostRecentSuite(suiteName);
    if (suite2)
      return suite2[hookType].push(cb);
    if (this.config?.verbose)
      console.warn(`Attempted to register ${hookType} hook for suite ${suiteName} that doesn't exist.`);
  }
  registerExclusion(suiteName, exclusionType, testCase) {
    const suite2 = this.getMostRecentSuite(suiteName);
    if (suite2)
      return suite2[exclusionType].push(testCase);
    if (this.config?.verbose)
      console.warn(`Attempted to register test.${exclusionType} for suite ${suiteName} that doesn't exist.`);
  }
  suite = (suiteName = "") => {
    if (!suiteName)
      return console.warn(`All test suites need a name. Skipping.`);
    const numSuites = Object.keys(this.MICROWAVE_SUITES).length;
    const newSuite = MicrowaveSuite.create(suiteName, this.registerTestCase, this.registerHook, this.registerExclusion);
    let mostRecentQueue = this.getMostRecentlyAddedSuiteQueue();
    if (!mostRecentQueue || mostRecentQueue.includes(suiteName)) {
      mostRecentQueue = [suiteName];
      this.MICROWAVE_SUITE_QUEUE.push(mostRecentQueue);
    } else {
      mostRecentQueue.push(suiteName);
    }
    const ctx = { __suite__: suiteName, __test__: "" };
    if (!Array.isArray(this.MICROWAVE_SUITES[suiteName])) {
      this.MICROWAVE_SUITES[suiteName] = [];
    }
    this.MICROWAVE_SUITES[suiteName].push(createDefaultMicrowaveSuiteStore(numSuites, newSuite, ctx));
    return newSuite;
  };
  deferredExec = async (deferMs = 25) => {
    return new Promise((resolve) => {
      setTimeout(async () => {
        const report = await this.exec();
        resolve(report);
      }, deferMs);
    });
  };
  exec = async () => {
    if (this.isRunning)
      return await this.deferredExec();
    if (this.config?.verbose)
      console.log("Executing tests...");
    this.isRunning = true;
    const report = new MicrowaveReport(this.appName);
    if (!this.MICROWAVE_SUITE_QUEUE.length) {
      if (this.config?.verbose)
        console.warn("No test suites registered yet. Skipping execution.");
      return report;
    }
    const suiteNames = this.MICROWAVE_SUITE_QUEUE.shift();
    const suitesToExec = [];
    for (const suiteName of suiteNames) {
      if (this.MICROWAVE_SUITES[suiteName]?.length) {
        const suite2 = this.MICROWAVE_SUITES[suiteName].shift();
        suitesToExec.push(suite2);
        if (!this.MICROWAVE_SUITES[suiteName].length) {
          delete this.MICROWAVE_SUITES[suiteName];
        }
      } else {
        if (this.config?.verbose)
          console.warn(`No suite found for '${suiteName}'`);
      }
    }
    let runOnly = false;
    for (const suite2 of suitesToExec) {
      if (suite2.only.length) {
        runOnly = true;
        break;
      }
    }
    let hook;
    for (const existingTestSuite of suitesToExec) {
      const { suite: suite2, order, tests, ctx } = existingTestSuite;
      const { before, beforeEach, after, afterEach } = existingTestSuite;
      const { only, skip } = existingTestSuite;
      const skipMapping = skip.reduce((acc, curr) => {
        return { ...acc, [curr.description]: true };
      }, {});
      const testsToRun = runOnly ? only : tests;
      const testSuiteSummary = new TestSuiteSummary(suite2.suiteName, order, tests.length);
      if (testsToRun.length) {
        for (hook of before)
          await hook(ctx);
        for (let testCaseOrder = 0; testCaseOrder < testsToRun.length; testCaseOrder++) {
          const testCase = testsToRun[testCaseOrder];
          const testCaseSummary = new TestCaseSummary(testCaseOrder, testCase.description, suite2.suiteName);
          let results = {
            e: void 0,
            retries: 0,
            status: "passed",
            name: testCase.description
          };
          if (skipMapping[testCase.description]) {
            results.status = "skipped";
            testCaseSummary.processTestCaseResults(results);
            testSuiteSummary.processTestCaseResultsSummary(testCaseSummary);
            continue;
          }
          for (hook of beforeEach)
            await hook(ctx);
          try {
            await testCase.test(ctx);
          } catch (e) {
            results.e = format(testCase.description, e, suite2.suiteName);
            results.status = "failed";
          } finally {
            testCaseSummary.processTestCaseResults(results);
            testSuiteSummary.processTestCaseResultsSummary(testCaseSummary);
          }
          for (hook of afterEach)
            await hook(ctx);
        }
        for (hook of after)
          await hook(ctx);
      }
      testSuiteSummary.finalizeSummary();
      report.processTestSuiteSummary(testSuiteSummary);
      report.finalizeReport();
    }
    if (this.config?.verbose)
      console.log("Finished executing tests");
    this.isRunning = false;
    return report;
  };
  getMostRecentSuite(suiteName) {
    const suiteArray = this.MICROWAVE_SUITES[suiteName];
    return Array.isArray(suiteArray) ? suiteArray[suiteArray.length - 1] : null;
  }
  getMostRecentlyAddedSuiteQueue() {
    return this.MICROWAVE_SUITE_QUEUE[this.MICROWAVE_SUITE_QUEUE.length - 1];
  }
};
var microwave = Microwave.create();
var updateConfig = (config) => microwave.updateConfig(config);
var suite = microwave.suite;
var test = () => suite();
var exec = microwave.exec;
//# sourceMappingURL=index.js.map