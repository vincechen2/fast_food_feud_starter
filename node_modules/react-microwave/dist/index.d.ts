declare type Opts = {
    message?: string;
    details: false | string;
    generated: boolean;
    operator: string;
    expects: any;
    actual: any;
};
declare class Assertion extends Error {
    name: "Assertion";
    code: "ERR_ASSERTION";
    details: false | string;
    generated: boolean;
    operator: string;
    expects: any;
    actual: any;
    constructor(opts: Opts);
}
declare type Types = "string" | "number" | "boolean" | "object" | "undefined" | "function";
declare type Message = string | Error;
declare type Detailer<Actual = any, Expects = any> = (actual: Actual, expects: Expects) => string;
declare function ok<T = any>(actual: T, msg?: Message): asserts actual;
declare function is(actual: any, expects: any, msg?: Message): void;
declare namespace is {
    var not: (val: any, exp: any, msg?: Message | undefined) => void;
}
declare function equal(actual: any, expects: any, msg?: Message): void;
declare function unreachable(msg?: Message): void;
declare function type(actual: any, expects: Types, msg?: Message): void;
declare function instance(actual: any, expects: any, msg?: Message): void;
declare function match(actual: string, expects: string | RegExp, msg?: Message): void;
declare function snapshot(actual: string, expects: string, msg?: Message): void;
declare function fixture(actual: string, expects: string, msg?: Message): void;
declare function throws(fn: Function, expects?: Message | RegExp | Function, msg?: Message): void;
declare function not(actual: any, msg?: Message): void;
declare namespace not {
    var ok: typeof not;
    var equal: (val: any, exp: any, msg?: Message | undefined) => void;
    var type: (val: any, exp: Types, msg?: Message | undefined) => void;
    var instance: (val: any, exp: any, msg?: Message | undefined) => void;
    var snapshot: (val: string, exp: string, msg?: Message | undefined) => void;
    var fixture: (val: string, exp: string, msg?: Message | undefined) => void;
    var match: (val: any, exp: string | RegExp, msg?: Message | undefined) => void;
    var throws: (blk: Function, exp?: Function | RegExp | Message | null | undefined, msg?: Message | undefined) => void;
}

type assert_Assertion = Assertion;
declare const assert_Assertion: typeof Assertion;
type assert_Message = Message;
type assert_Detailer<Actual = any, Expects = any> = Detailer<Actual, Expects>;
declare const assert_ok: typeof ok;
declare const assert_is: typeof is;
declare const assert_equal: typeof equal;
declare const assert_unreachable: typeof unreachable;
declare const assert_type: typeof type;
declare const assert_instance: typeof instance;
declare const assert_match: typeof match;
declare const assert_snapshot: typeof snapshot;
declare const assert_fixture: typeof fixture;
declare const assert_throws: typeof throws;
declare const assert_not: typeof not;
declare namespace assert {
  export {
    assert_Assertion as Assertion,
    assert_Message as Message,
    assert_Detailer as Detailer,
    assert_ok as ok,
    assert_is as is,
    assert_equal as equal,
    assert_unreachable as unreachable,
    assert_type as type,
    assert_instance as instance,
    assert_match as match,
    assert_snapshot as snapshot,
    assert_fixture as fixture,
    assert_throws as throws,
    assert_not as not,
  };
}

declare type AnyFunction<P extends Parameters<any> = Parameters<any>, R = any> = (...args: P) => R;
declare type MicrowaveReporters = {
    json?: boolean;
    console?: boolean;
    html?: boolean;
};
declare type MicrowaveConfig = {
    appName?: string;
    verbose?: boolean;
    reporters?: Partial<MicrowaveReporters>;
};
declare type MicrowaveContext = Record<string, any>;
declare type MicrowaveTestBaseCallback<T> = (context: T) => Promise<void> | void;
interface MicrowaveBaseHook<T> {
    (hook: MicrowaveTestBaseCallback<T>): Promise<void> | void;
    each?: (hook: MicrowaveTestBaseCallback<T>) => void;
}
interface RegisterMicrowaveTestCase<T> {
    (description: string, test: MicrowaveTestBaseCallback<T>): void;
    only(description: string, test: MicrowaveTestBaseCallback<T>): void;
    skip(description?: string, test?: MicrowaveTestBaseCallback<T>): void;
    before: MicrowaveBaseHook<T>;
    after: MicrowaveBaseHook<T>;
    run(): IMicrowaveSuite;
}
declare type MicrowaveTest<T> = RegisterMicrowaveTestCase<T>;
declare type MicrowaveTestCallback<T = MicrowaveContext> = MicrowaveTestBaseCallback<T>;
declare type MicrowaveHook<T = MicrowaveContext> = MicrowaveBaseHook<T>;
declare type RegisterTestCase<T = MicrowaveContext> = (suiteName: string, testCase: {
    description: string;
    test: MicrowaveTestCallback<T>;
}) => void;
declare type RegisterHook<T = MicrowaveContext> = (suiteName: string, hookType: MicrowaveSuiteHookType, cb: MicrowaveTestCallback<T>) => void;
declare type RegisterExclusion<T = MicrowaveContext> = (suiteName: string, exclusionType: MicrowaveSuiteExclusionType<T>, testCase: {
    description: string;
    test: MicrowaveTestCallback<T>;
}) => void;
declare type MicrowaveSuiteHooks<T = MicrowaveContext> = {
    before: MicrowaveTestCallback<T>[];
    after: MicrowaveTestCallback<T>[];
    beforeEach: MicrowaveTestCallback<T>[];
    afterEach: MicrowaveTestCallback<T>[];
};
declare type MicrowaveSuiteExclusions<T = MicrowaveContext> = {
    only: Array<{
        description: string;
        test: MicrowaveTestCallback<T>;
    }>;
    skip: Array<{
        description: string;
        test: MicrowaveTestCallback<T>;
    }>;
};
declare type MicrowaveSuiteHookType = keyof MicrowaveSuiteHooks;
declare type MicrowaveSuiteExclusionType<T = MicrowaveContext> = keyof MicrowaveSuiteExclusions<T>;
interface IMicrowaveSuite<T = MicrowaveContext> {
    suiteName: string;
    isRegistered: boolean;
    registerTestCase: RegisterTestCase;
    registerHook: RegisterHook;
    registerExclusion: RegisterExclusion;
    test: (description: string, test: MicrowaveTestCallback<T>) => void;
    before: MicrowaveBaseHook<T>;
    after: MicrowaveBaseHook<T>;
    beforeEach: MicrowaveBaseHook<T>;
    afterEach: MicrowaveBaseHook<T>;
    run: () => IMicrowaveSuite<T>;
}
declare type MicrowaveSuiteStore<T = MicrowaveContext> = MicrowaveSuiteHooks & MicrowaveSuiteExclusions & {
    order: number;
    ctx: T;
    suite: IMicrowaveSuite;
    tests: {
        description: string;
        test: MicrowaveTestCallback;
    }[];
    hasOnly: boolean;
};
declare type SuitesMapping = Record<string, MicrowaveSuiteStore[]>;
declare type SuiteName = keyof SuitesMapping;
declare type IReportTimer = {
    startTs: number;
    finishTs: number;
    duration: number;
};
declare type ReportStats = IReportTimer & {
    total: number;
    passed: number;
    failed: number;
    skipped: number;
    ok: boolean;
};
declare type TestCaseResultsStatus = "passed" | "failed" | "timedOut" | "skipped";
declare type TestCaseSummaryResults = IReportTimer & {
    order: number;
    description: string;
    suiteName: string;
    annotations: {
        type: string;
        description?: string;
    }[];
    ok: boolean;
    retry: number;
    errors: string[];
    status: TestCaseResultsStatus;
};
declare type TestSuiteSummaryResults = {
    suiteOrder: number;
    suiteName: string;
    tests: TestCaseSummaryResults[];
    stats: ReportStats;
};
declare type MicrowaveReportJson = {
    suites: TestSuiteSummaryResults[];
    stats: ReportStats;
    projectName?: string;
};
interface IMicrowaveTimer {
    startTs: number;
    finishTs?: number;
    duration?: number;
    stopTimer: () => string | number;
}
interface ITestCaseSummary {
    results: TestCaseSummaryResults;
    processTestCaseResults(testCaseResults: {
        e?: string;
        name?: string;
        status: TestCaseSummaryResults["status"];
        retries?: number;
    }): void;
    finalizeSummary(): void;
    toJson(): TestCaseSummaryResults;
}
interface ITestSuiteSummary {
    summary: TestSuiteSummaryResults;
    processTestCaseResultsSummary(testCaseSummary: ITestCaseSummary): void;
    finalizeSummary(): void;
    toJson(): TestSuiteSummaryResults;
}
interface IMicrowaveReport {
    report: MicrowaveReportJson;
    processTestSuiteSummary(testSuiteSummary: ITestSuiteSummary): void;
    finalizeReport(): void;
    toJson(): MicrowaveReportJson;
}

declare class MicrowaveSuite implements IMicrowaveSuite {
    suiteName: string;
    isRegistered: boolean;
    registerTestCase: RegisterTestCase;
    registerHook: RegisterHook;
    registerExclusion: RegisterExclusion;
    static create(suiteName: string | undefined, registerTestCase: RegisterTestCase, registerHook: RegisterHook, registerExclusion: RegisterExclusion): MicrowaveSuite;
    private constructor();
    test: (description: string, test: MicrowaveTestCallback) => void;
    before: MicrowaveHook;
    beforeEach: (cb: MicrowaveTestCallback) => void;
    after: MicrowaveHook;
    afterEach: (cb: MicrowaveTestCallback) => void;
    only: (description: string, test: MicrowaveTestCallback) => void;
    skip: (description: string, test: MicrowaveTestCallback) => void;
    run: () => this;
}

declare const updateConfig: (config: MicrowaveConfig) => void;
declare const suite: (suiteName?: string) => void | MicrowaveSuite;
declare const test: () => void | MicrowaveSuite;
declare const exec: () => Promise<IMicrowaveReport>;

export { AnyFunction, IMicrowaveReport, IMicrowaveSuite, IMicrowaveTimer, IReportTimer, ITestCaseSummary, ITestSuiteSummary, MicrowaveBaseHook, MicrowaveConfig, MicrowaveContext, MicrowaveHook, MicrowaveReportJson, MicrowaveReporters, MicrowaveSuiteExclusionType, MicrowaveSuiteExclusions, MicrowaveSuiteHookType, MicrowaveSuiteHooks, MicrowaveSuiteStore, MicrowaveTest, MicrowaveTestBaseCallback, MicrowaveTestCallback, RegisterExclusion, RegisterHook, RegisterMicrowaveTestCase, RegisterTestCase, ReportStats, SuiteName, SuitesMapping, TestCaseResultsStatus, TestCaseSummaryResults, TestSuiteSummaryResults, assert, exec, suite, test, updateConfig };
